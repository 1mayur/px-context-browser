<!--
    Import dependencies, assuming relative to this project which works when this component is consumed downstream.
    See tests/examples within this project re-specify these paths locally to this component.
 -->
<link rel="import" href="../../polymer/polymer.html"/>


<polymer-element name="px-3-column-browser" attributes="treeData handlers labelField parentIdField idField headers childKey">

<template>
    <link rel="stylesheet" href="css/px-3-column-browser.css"/>
    <div class="asset-browser">
        <div class="px-tree-nav">
            <div class="px-tree-breadcrumbs" hidden?="{{!showBreadcrumbs}}">
            <span on-click="{{handleBreadcrumbClick}}" data-level="0">{{parentNodes[0].header}}</span>
            <span hidden?="{{!isEllipsisShown()}}" id="px-tree-breadcrumbs-ellipsis">...</span>
            <template repeat="{{p, pIndex in parentNodes}}">
                <span hidden?="{{!isBreadcrumbVisible(pIndex)}}" on-click="{{handleBreadcrumbClick}}" data-level="{{pIndex}}" class="px-tree-breadcrumb">
                {{getBreadcrumb(p)}}&nbsp;&gt;&nbsp;
                </span>
            </template>
        </div>
        <div class="px-tree-nav-row">
            <template repeat="{{n in displayNodes}}">
                <div class="px-tree-level">
                    <table class="table table-condensed px-tree-table">
                        <thead>
                        <th class="px-tree-header">{{n.header}}</th>
                        </thead>
                        <tbody template if="{{n.children.length > 0}}" repeat="{{item in n.children}}">
                        <tr>
                            <td class="{{ {active: item.selected === true} | tokenList}}" on-click="{{rowClickHandler}}">
                                <span class="px-tree-item">{{item[labelField]}}</span>
                                <i class="icon-ico_chevron_right_sm" hidden?="{{item.selected}}"></i>
                            </td>
                        </tr>
                        </tbody>
                        <tbody template if="{{n.children.length === 0}}" class="empty">
                        <tr>
                            <td>{{dashboard.contextbrowser.nochildren}}</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </template>
        </div>
        <button class="btn px-tree-open-btn" on-click="{{openClickHandler}}" hidden?="{{!isOpenable(selectedItem)}}">Open</button>
    </div>
    </div>
</template>

<script>
Polymer({

    publish: {
        ngScopeToken: "ngScope:",
        treeDisplayLevels: 1,
        showBreadcrumbs: true,
        showOpenButton: true,
        currentLevel: {value: -1, reflect: true} //need to reflect back properties to attributes per angular-bind-polymer
    },

    ready: function() {
        console.log('ready');
        if (window['angular'] && this.hasAttributes()) {
            //if angular exists and was passed 'ngScope:a.b.c' for any attribute, fish object value from current angular scope.
            var ngScope = angular.element(this).scope();
            for (var i = 0; i < this.attributes.length; i++) {
                this.resolveNgScopeAttr(ngScope, this.attributes[i].name, this.attributes[i].value);
            }
        }
    },

    resolveNgScopeAttr: function(ngScope, attrName, attrValue) {
        var scopePath, scopeTokens, i, resolvedValue;
        if (attrValue.indexOf(this.ngScopeToken) === 0) {
            scopePath = attrValue.substring(this.ngScopeToken.length);
            console.log("scopePath=" + scopePath);
            scopeTokens = scopePath.split('.');
            resolvedValue = ngScope;
            for (i = 0; i < scopeTokens.length; i++) {
                //iterate over the dots values in 'a.b.c' to find the final resolved value
                resolvedValue = resolvedValue[scopeTokens[i]];
            }
            this[attrName] = resolvedValue;
        }
    },

    treeDataChanged: function(oldValue, newValue) {
        console.log('treeDataChanged2: ' + oldValue + " " + newValue);
        var treeData = this.treeData;
        if (typeof treeData === 'string') {
            treeData = JSON.parse(treeData);
        }
        this.updateTreeData(treeData);
    },

    parentNodes: [{}],

    selectedItem: null,

    displayNodes: null,

    updateTreeData: function(newData) {

        if (this.shouldAddData(newData)) {

            // set the current level to the next level (use parentNodes so multiple clicks don't mess up)
            this.currentLevel = this.parentNodes.length - 1;

            // set up the children/parent pointers
            for (var i = 0; i < newData.length; i++) {
                newData[i].parent = this.parentNodes[this.currentLevel];
            }
            this.parentNodes[this.currentLevel].children = newData;

            // set the new node's header
            if (this.headers) {
                this.parentNodes[this.currentLevel].header = this.headers[this.currentLevel];
            }
            else {
                this.parentNodes[this.currentLevel].header = '';
            }

            // set the new node's level
            this.parentNodes[this.currentLevel].level = this.currentLevel;

            // update the display
            this.setDisplayNodes();
        }
    },

    handleBreadcrumbClick: function(event, detail, sender) {
        var level = sender.getAttribute('data-level');
        this.selectNode(this.parentNodes[level]);
    },

    isBreadcrumbVisible: function (index) {
        console.log("index=" + index);
        return (index > 0 && (index >= (this.parentNodes.length - this.treeDisplayLevels)));
    },

    isEllipsisShown: function() {
        // since parentNodes has 1 more than breadcrumbs (for the initial header support), add 1
        return this.parentNodes.length > (this.treeDisplayLevels + 1);
    },

    shouldAddData: function(newData) {
        if (!newData) {
            // if no new data don't add it
            return false;
        }
        if (this.selectedItem && newData.length > 0 && newData[0][this.parentIdField] !== this.selectedItem[this.idField]) {
            // if the parent of the child is NOT the selected item, then the data is out of date so don't add it
            // (the data is the children from a previous item click)
            return false;
        }
        return true;
    },

    markNodeSelected: function(node) {
        // mark all other nodes on this level unselected
        for (var j=0; j<node.parent.children.length; j++) {
            node.parent.children[j].selected = false;
        }
        node.selected = true;
        this.selectedItem = node;
    },

    dropCurrentChildren: function(node) {

        // drop the children from the master list of nodes (and update the level)
        for (var i=0; i<this.parentNodes.length-1; i++) {
            if (this.parentNodes[i] === node.parent) {
                this.currentLevel = i;
                this.parentNodes = this.parentNodes.slice(0, i + 1);
            }
        }

        // drop the children from the displayed nodes (so old nodes don't linger during next GET for children)
        for(var j=0; j<this.displayNodes.length-1; j++) {
            if(this.displayNodes[j] === node.parent) {
                this.displayNodes = this.displayNodes.slice(0, j + 1);

            }
        }
    },

    getNewChildren: function(node) {
        if (this.handlers.getChildren) {
            // push the node to the parentNodes so breadcrumbs updated even if children not successfully returned
            this.parentNodes.push(node);
            var _this = this;
            this.handlers.getChildren(node).then(function (children) {
                _this.treeData = children;
            });
        }
        else {
            if (this.childKey) {
                this.treeData = node[this.childKey];
            } else if (node.subcontexts) {
                this.treeData = node.subcontexts;
            } else {
                console.log('The next level of children could not be returned.');
                return; //do not put anything else in tree
            }
            this.parentNodes.push(node);
        }
    },

    selectNode: function(node) {
        this.markNodeSelected(node);
        this.dropCurrentChildren(node);
        this.getNewChildren(node);
    },

    rowClickHandler: function(event, detail, sender) {
        var node = sender.templateInstance.model.item;
        if (this.handlers.itemClickHandler) {
            this.handlers.itemClickHandler(node);
        }

        this.selectNode(node);
    },

    openClickHandler: function(event, detail, sender) {
        if (this.selectedItem && this.handlers.itemOpenHandler) {
            var breadcrumbs = [];
            for (var index in this.parentNodes) {
                if(index < this.parentNodes.length - 1) {
                    breadcrumbs.push(this.getBreadcrumb(this.parentNodes[index], index));
                }
            }
            this.handlers.itemOpenHandler(this.selectedItem, breadcrumbs);
        }
    },

    getBreadcrumb: function(node) {
        if(node && node.hasOwnProperty(this.labelField)) {
            return node[this.labelField];
        }
        return '';
    },

    setDisplayNodes: function() {
        var beginIndex = 0;
        if (this.treeDisplayLevels < this.parentNodes.length) {
            beginIndex = this.parentNodes.length - this.treeDisplayLevels;
        }
        this.displayNodes = this.parentNodes.slice(beginIndex);
    },

    isOpenable: function(selectedItem) {
        if(this.showOpenButton && this.handlers.isOpenable) {
            return this.handlers.isOpenable(selectedItem);
        }
        return false;
    }

});
</script>

</polymer-element>
