<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.sw.ge.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html"/>


<!--
3-column browser element

##### Usage

    <px-context-browser initial-contexts="{{ ... }}"
                        handlers="{{ ... }}"
                        label-field="{{ ... }}"
                        parent-id-field="{{ ... }}"
                        id-field="{{ ... }}"
                        headers="{{ ... }}"
                        child-key="{{ ... }}"></px-context-browser>

@element px-context-browser
@blurb 3-column browser element
@homepage index.html
-->
<dom-module id="px-context-browser">
  <link rel="import" type="css" href="css/px-context-browser.css" polyfill-next-selector/>
  <template>
    <header class="p-">
      <div hidden$="[[!showBreadcrumbs]]">
        <template is="x-repeat" id="breadcrumbs" items="{{parentNodes}}">
          <span class="breadcrumb" on-click="handleBreadcrumbClick">[[item.name]]</span>
          &gt;
        </template>
      </div>
      <div>
        <content></content>
      </div>
    </header>
    <section class="flex">
      <template is="x-repeat" id="levels" items="{{displayNodes}}">
        <div class="flex__item p-">
          <span>{{item.header}}</span>
          <ul class="list-bare level" on-scroll="scrollEndHandler">
            <!-- see https://groups.google.com/forum/#!topic/polymer-dev/CMQRzKPV5Ww for explanation of the '&& selectedItem' part below -->
            <template is="x-repeat" items="{{item.children}}" id="level">
              <li>
                <!--<td class$="[[getItemStyleClass(item)]]" on-click="{{rowClickHandler}}">-->
                <!--<span class="px-tree-item">[[getItemLabel(item)]]</span>-->
                <!--<i class="fa fa-chevron-right" hidden$="[[item | selectedFilter}}"></i>-->
                <!--</td>-->
                <div class="selectable-item" on-click="rowClickHandler">
                  <span>[[item.name]]</span>
                  <i class="fa fa-chevron-right" hidden$="[[item]]"></i>
                </div>
              </li>
            </template>
            <li hidden$="[[!item.children || item.children.length > 0]]">This context has no children.</li> <!-- todo: i18n / messages. Runtime or build-time?? -->
          </ul>
        </div>
      </template>
    </section>
    <footer class="p- clearfix">
      <button class="btn btn--bare pull-right" on-click="openClickHandler" hidden$="[[!isOpenable(selectedItem)]]">Open</button>
    </footer>
  </template>
</dom-module>

<script>
Polymer({

  is: 'px-context-browser',
  properties: {
    parentIdField: {
      type: String
    },
    idField: {
      type: String
    },
    headers: {
    },
    treeDisplayLevels: {
      value : 1,
      type: Number
    },
    labelField: {
      type: String
    },
    currentLevel: {
      value: -1,
      type: Number//need to reflect back properties to attributes per angular-bind-polymer
    },
    showBreadcrumbs: {
      value: true,
      type: Boolean
    },
    showOpenButton: {
      value: true,
      type: Boolean
    },
    handlers:{
      type: Object,
      value:function(){ return {};}
    },
    initialContexts:{
      value: null,
      observer: 'initialContextsChanged'
    },
    parentNodes: {
      type: Array,
      value: []
    },
    rootBreadcrumb: {
      type: String,
      computed: 'computeRootBreadcrumb(parentNodes)'
    }
  },

  ngScopeToken: "ngScope:",

  ready: function() {



    if (window['angular'] && this.hasAttributes()) {
      //if angular exists and was passed 'ngScope:a.b.c' for any attribute, fish object value from current angular scope.
      var ngScope = angular.element(this).scope();
      for (var i = 0; i < this.attributes.length; i++) {
        this.resolveNgScopeAttr(ngScope, this.attributes[i].name, this.attributes[i].value);
      }
    }
  },

  resolveNgScopeAttr: function(ngScope, attrName, attrValue) {
    var scopePath, scopeTokens, i, resolvedValue;
    if (attrValue.indexOf(this.ngScopeToken) === 0) {
      scopePath = attrValue.substring(this.ngScopeToken.length);
      console.log("scopePath=" + scopePath);
      scopeTokens = scopePath.split('.');
      resolvedValue = ngScope;
      for (i = 0; i < scopeTokens.length; i++) {
        //iterate over the dots values in 'a.b.c' to find the final resolved value
        resolvedValue = resolvedValue[scopeTokens[i]];
      }
      this[attrName] = resolvedValue;
    }
  },

  initialContextsChanged: function(newValue, oldValue) {
    var initialContexts = this.initialContexts;
    if (typeof initialContexts === 'string') {
      if (initialContexts.length > 0) {
        initialContexts = JSON.parse(initialContexts);
      }
      else {
        initialContexts = null;
      }
    }
    var root = {name: "root"};
    this.parentNodes = [root];
    this.addChildren(root, initialContexts);
  },

  //see https://groups.google.com/forum/#!topic/polymer-dev/CMQRzKPV5Ww for why selected item is not null
  // we rely on a change observer on it and if null then our if statement in the template will eval false.
  selectedItem: "temp",

  displayNodes: null,

  appendChildren: function (node, results) {
    if (results === undefined || results === null) {
      return;
    }
    var children = results.data || [];

    // set up the parent pointers
    for (var i = 0; i < children.length; i++) {
      children[i].parent = node;
    }

    // adding all the new children onto the node's children
    Array.prototype.push.apply(node.children, children);

    // update the display
    this.setDisplayNodes();
  },

  addChildren: function(parentNode, results) {

    if (results === undefined || results === null) {
      return;
    }
    var children = results.data || [];

    // set up the parent pointers
    for (var i = 0; i < children.length; i++) {
      children[i].parent = parentNode;
    }

    parentNode.children = children;
    parentNode.childrenCount = results.meta.total;

    // update the display
    this.setDisplayNodes();
  },

  handleBreadcrumbClick: function(event, detail, sender) {
    var level = this.$.breadcrumbs.indexForElement(event.target); //"$.breadcrumbs" is id of the template element with x-repeat
    if (level > 0) {//"root" is a no-op
      this.selectNode(this.parentNodes[level]);
    }
  },

  isEllipsisShown: function() {
    // since parentNodes has 1 more than breadcrumbs (for the initial header support), add 1
    return this.parentNodes.length > (this.treeDisplayLevels + 1);
  },

  isShowChildren: function(item) {
    return item.children.length > 0 && this.selectedItem;
  },

  isShowEmptyMsg: function(item) {
    return !item.children || item.children.length === 0;
  },

  getItemLabel: function(item) {
    return item[this.labelField];
  },

  getItemStyleClass: function(item) {
    return item.selected ? "active" : null;
  },

  computeRootBreadcrumb: function(parentNodes) {
    return (parentNodes && parentNodes.length > 0) ? this.getItemLabel(parentNodes[0]) : null;
  },

  markNodeSelected: function(node) {
    this.selectedItem = node;
    var _this = this;
    node.parent.children.forEach(function(siblingOrSelf) {
      siblingOrSelf.selected = (siblingOrSelf[_this.idField] === node[_this.idField]);
    });
  },

  dropCurrentChildren: function(node) {
    // drop the children from the master list of nodes (and update the level)
    for (var i = 0; i < this.parentNodes.length - 1; i++) {
      if (this.parentNodes[i] === node.parent) {
        this.parentNodes = this.parentNodes.slice(0, i + 1);
      }
    }

    // drop the children from the displayed nodes (so old nodes don't linger during next GET for children)
    for (var j = 0; j < this.displayNodes.length - 1; j++) {
      if (this.displayNodes[j] === node.parent) {
        this.displayNodes = this.displayNodes.slice(0, j + 1);

      }
    }
  },

  getNewChildren: function(node) {
    if (this.handlers.getChildren) {
      // push the node to the parentNodes so breadcrumbs updated even if children not successfully returned
      this.parentNodes.push(node);
      var _this = this;
      this.handlers.getChildren(node[_this.idField]).then(function (children) {
        _this.addChildren(node, children);
      });
    }
    else {
      if (this.childKey) {
        this.addChildren(node, node[this.childKey]);
      }
      else if (node.subcontexts) {
        this.addChildren(node, node.subcontexts);
      }
      else {
        console.log('The next level of children could not be returned.');
        return; //do not put anything else in tree
      }
      this.parentNodes.push(node);
    }
  },

  selectNode: function(node) {
    this.markNodeSelected(node);
    this.dropCurrentChildren(node);
    this.getNewChildren(node);
  },

  selectedFilter: function(node) {
    return !node.selected;
  },

  rowClickHandler: function(evt, detail, sender) {
    var levelTemplateRepeat = Polymer.dom(this.root).querySelector('template#level');//can't use this.$.id to find this template as it is within an x-repeat
    var node = levelTemplateRepeat.itemForElement(evt.target);
    if (this.handlers.itemClickHandler) {
      this.handlers.itemClickHandler(node);
    }

    this.selectNode(node);
  },

  scrollEndHandler: function (evt, detail, sender) {
    // executes when it hasn't been called for 500ms
    var _this = this;
    var levelIdx = this.$.levels.indexForElement(evt.target);
    this.debounce('scroll-panel', function() {
      if (this.handlers.getChildren) {
        var node = this.parentNodes[levelIdx];
        if (!node || !node.childrenCount || (node.childrenCount !== undefined && node.children.length >= node.childrenCount)) {
          return;
        }
        this.handlers.getChildren(node[_this.idField], node.children.length).then(function (children) {
          _this.appendChildren(node, children);
        });
      }
    }, 500);
  },

  openClickHandler: function(evt, detail, sender) {
    if (this.selectedItem && this.handlers.itemOpenHandler) {
      var breadcrumbs = [];
      for (var index in this.parentNodes) {
        if (index < this.parentNodes.length - 1) {
          breadcrumbs.push(this.getBreadcrumb(this.parentNodes[index], index));
        }
      }
      this.handlers.itemOpenHandler(this.selectedItem, breadcrumbs);
    }
  },

  getBreadcrumb: function(node) {
    if (node && node.hasOwnProperty(this.labelField)) {
      return node[this.labelField];
    }
    return '';
  },

  isOpenable: function(selectedItem) {
    if(this.showOpenButton && this.handlers.isOpenable) {
      return this.handlers.isOpenable(selectedItem);
    }
    return false;
  },

  setDisplayNodes: function() {
    var beginIndex = 0;
    if (this.treeDisplayLevels < this.parentNodes.length) {
      beginIndex = this.parentNodes.length - this.treeDisplayLevels;
    }
    this.displayNodes = this.parentNodes.slice(beginIndex);
  }

});
</script>
