<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.sw.ge.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<!--suppress HtmlUnknownTarget -->
<link rel="import" href="../polymer/polymer.html"/>


<!--
Context browser element

##### Usage

    <px-context-browser initial-contexts="{{ ... }}"
                        handlers="{{ ... }}"
                        label-field="{{ ... }}"
                        parent-id-field="{{ ... }}"
                        id-field="{{ ... }}"
                        child-key="{{ ... }}">
        <section class="context-info">optional, will appear below the breadcrumbs</section>
        <footer>optional, will appear in the footer</footer>
    </px-context-browser>

@element px-context-browser
@blurb Context browser element
@homepage index.html
-->
<dom-module id="px-context-browser">
  <link rel="import" type="css" href="css/px-context-browser.css" polyfill-next-selector/>
  <link rel="import" type="css" href="css/px-context-browser-2.css" polyfill-next-selector/>
  <template>
    <div class="flex flex--column context-browser-container">
      <header class="p--">
        <div>
          <template is="x-repeat" id="breadcrumbs" items="{{parentNodes}}">
          <span hidden$="[[item.hideBreadcrumb]]">
            <span class="breadcrumb" on-click="handleBreadcrumbClick">[[item.name]]</span>
          </span>
          <span class="breadcrumbConnector" hidden$="[[item.hideBreadcrumb]]">
            <i class$="[[parent.itemConnectorClass]]"></i>
          </span>
          </template>
          &nbsp;
        </div>
        <div>
          <content select=".context-info"></content>
        </div>
      </header>
      <section id="columnBrowser" class="column-browser">
        <div>
          <template is="x-repeat" id="levels" items="{{displayNodes}}">
            <div>
              <div data-column>
                <span>{{item.header}}</span>
                <ul class="list-bare level" on-scroll="scrollEndHandler">
                  <!-- see https://groups.google.com/forum/#!topic/polymer-dev/CMQRzKPV5Ww for explanation of the '&& selectedItem' part below -->
                  <template is="x-repeat" items="{{item.children}}" id="level">
                    <li on-click="itemClickHandler" id$="[[parent.parent.getItemId(item)]]" class="selectable-item">
                      <span>[[parent.parent.getItemLabel(item)]]</span>
                      <span hidden$="[[!item.hasChildren]]" class="pull-right pl-">
                        <i class$="[[parent.parent.itemConnectorClass]]"></i>
                      </span>
                      <i class$="[[parent.parent.getItemOpenerClass(item)]]" on-click="openClickHandler"></i>
                    </li>
                  </template>
                  <li hidden$="[[!item.children || item.children.length === 0]]">This context has no children.</li>
                  <!-- todo: i18n / messages. Runtime or build-time?? -->
                </ul>
              </div>
            </div>
          </template>
        </div>
        <div class="ruler">
          <!-- Use this as a ruler/measuring-stick to measure the true minimum width. -->
        </div>
      </section>
      <footer class="p-- clearfix flex__item" hidden$="[[!hasFooter]]">
        <content select="footer"></content>
        <content select=".footer"></content>
      </footer>
    </div>
  </template>
</dom-module>

<script>
Polymer(
  {

    is: 'px-context-browser',
    properties: {

      /**
       * Mapping for the field name in the context data that represents the display label for an item. This property allows data of any form/keys to be used as
       * long as it has the notion of a 'display label' in it.
       *
       * @type {String}
       * @default "name"
       */
      labelField: {
        type: String,
        value: "name"
      },

      /**
       * Mapping for the field name in the context data that represents a unique id for an item. This property allows data of any form/keys to be used as
       * long as it has the notion of a 'unique id' in it.
       *
       * @type {String}
       * @default "id"
       */
      idField: {
        type: String,
        value: "id"
      },

      /**
       * Mapping for the field name in the context data that points up to the parent id of an item. This property allows data of any
       * form/keys to be used as long as it has the notion of a 'parent id' in it.
       *
       * @type {String}
       * @default "parent"
       */
      parentIdField: {
        type: String,
        value: "parent"
      },

      /**
       * Starting level of context. Contains an Array of items that include keys that match the "idField", "parentId"
       * field, and "labelField" properties on this component.
       *
       * Required. Setting this property is essentially this component's 'main' function.
       *
       * @type {Object}
       * @required
       */
      initialContexts: {
        value: null,
        observer: 'initialContextsChanged'
      },

      /**
       * "Preferred" number of columns in the browser. Actual number of columns will be responsive depending on width.
       *
       * @type {Number}
       * @default 3
       */
      treeDisplayLevels: {
        value: 3,
        type: Number
      },

      /**
       * Id of item currently selected, reflected back as an attribute so application can detect which item is selected
       * (e.g. via angular-bind-polymer)
       *
       * @type {String}
       */
      selectedItemId: {
        type: String,
        value: null,
        reflectToAttribute: true
      },

      /**
       * Object defining some or all of the following functions as members:
       *
       * isOpenable: function(item) {} returns whether the given context item is open-able as a context
       * itemOpenHandler: function(item) {} returns special callback behavior when a given context item is opened
       * itemClickHandler: function(item) {} returns special callback behavior when a given context is selected
       * getChildren: function (parentId, startIdx) {} returns a JavaScript promise that will resolve to children of the given id and starting with the given index (to support lazy loading)
       *
       * @type {Object}
       */
      handlers: {
        type: Object
      },

      /**
       * Hierarchy of items down to currently selected item. Set here as a property to expose it to the template, but managed internally. Do not set this.
       *
       * @type {Array}
       * @default []
       */
      parentNodes: {
        type: Array,
        value: []
      },

      /**
       * Item connector css class ("<" or ">") for breadcrumbs and item children affordance.
       * Set here as a property to expose it to the template, but managed internally. Do not set this.
       *
       * Re-evaluates when items are selected
       *
       * @type {String}
       * @default
       */
      itemConnectorClass: {
        type: String,
        computed: 'computeLocalizedItemConnector(selectedItemId)' //passing in selectedItemId as computed only fires when an arg passed to the fn changes
      }
    },

    /**
     * Which items are displayed given the number of visible columns
     *
     * @private
     */
    displayNodes: null,

    /**
     * Ready lifecycle callback
     */
    ready: function() {

      //hide the footer if empty (hidden$="..." doesn't help us here(?)
      var pDom = Polymer.dom(this.root);
      this.toggleClass('empty', (!pDom.querySelector('content .footer') && !pDom.querySelector('content footer')), pDom.querySelector('footer'));

      //TBD whether we need this...only way to get 'handlers' correctly parsed in Polymer 0.5. May be able to dump now.  TBD.
      if(window['angular'] && this.hasAttributes())
      {
        //if angular exists and was passed 'ngScope:a.b.c' for any attribute, fish object value from current angular scope.
        var ngScope = angular.element(this.root).scope();
        for(var i = 0; i<this.attributes.length; i++)
        {
          this.resolveNgScopeAttr(ngScope, this.attributes[i].name, this.attributes[i].value);
        }
      }


      // Need to watch the width of the column-browser.
      var columnBrowser = this.$.columnBrowser;
      var columnBrowserColumnRuler = Polymer.dom(columnBrowser).querySelector('.ruler');
      var columnBrowserColumns = Polymer.dom(columnBrowser).querySelector('div:first-child');
      var columnBrowserColumnsBaseCss = columnBrowserColumns.className; // Polymer does weird stuff.
      var $columnBrowserColumns = Polymer.dom(columnBrowserColumns);
      // Watch the container size change.
      var contextBrowserWidth, contextBrowserChildrenCount;
      setInterval(function(){
        var width = columnBrowser.offsetWidth;
        var removedCount = $columnBrowserColumns.querySelectorAll('.removed').length;
        var cCount = columnBrowserColumns.childNodes.length - removedCount;
        if(width!==contextBrowserWidth || cCount!=contextBrowserChildrenCount) {
          contextBrowserWidth = width;
          contextBrowserChildrenCount = cCount;
          var count = $columnBrowserColumns.childNodes.filter(function(n){
              return n.tagName=='DIV';
            }).length - removedCount;
          var columns = Math.floor(width / columnBrowserColumnRuler.offsetWidth);
          var desiredClass = columnBrowserColumnsBaseCss + ' columns-'+columns;

          if(count>columns) {
            desiredClass += " column-index-"+(count-columns);
          }

          if(columnBrowserColumns.className!=desiredClass) {
            columnBrowserColumns.className = desiredClass;
          }
        }
      },1000/20); // ms/fps

    },

    /**
     * Event listener on breadcrumb clicks, listener is registered from the template
     *
     * @param {Event} evt
     * @private
     */
    handleBreadcrumbClick: function(evt) {
      var level = this.$.breadcrumbs.indexForElement(evt.target); //"$.breadcrumbs" is id of the template element with x-repeat
      this.selectItem(this.parentNodes[level]);
    },

    /**
     * Event listener on item clicks, listener is registered from the template
     *
     * @param {Event} evt
     * @private
     */
    itemClickHandler: function(evt) {
      var levelTemplateRepeat = Polymer.dom(this.root).querySelector('template#level');//can't use this.$.id to find this template as it is within an x-repeat
      var item = levelTemplateRepeat.itemForElement(evt.target);
      this.selectItem(item, evt.currentTarget);
    },

    /**
     * Event listener on scroll of item panels/columns, listener is registered from the template
     *
     * @param {Event} evt
     * @private
     */
    scrollEndHandler: function(evt) {
      // executes when it hasn't been called for 500ms
      var _this = this;
      var levelIdx = this.$.levels.indexForElement(evt.target);
      this.debounce(
        'scroll-panel', function() {
          if(this.handlers.getChildren)
          {
            var item = this.parentNodes[levelIdx];
            if(!item || !item.childrenCount || (item.childrenCount!==undefined && item.children.length>=item.childrenCount))
            {
              return;
            }
            this.handlers.getChildren(item[_this.idField], item.children.length).then(
              function(children) {
                _this.appendChildren(item, children);
              });
          }
        }, 500);
    },

    /**
     * Event listener on 'open' button of open-able items, listener is registered from the template
     *
     * @param {Event} evt
     * @private
     */
    openClickHandler: function(evt) {
      evt.stopPropagation();
      if(this.selectedItem && this.handlers.itemOpenHandler)
      {
        var breadcrumbs = [];
        for(var index in this.parentNodes)
        {
          if(index<this.parentNodes.length - 1)
          {
            //noinspection JSUnfilteredForInLoop
            breadcrumbs.push(this.getItemLabel(this.parentNodes[index]));
          }
        }
        this.handlers.itemOpenHandler(this.selectedItem, breadcrumbs);
      }
    },

    /**
     * Observer / sets the value of the itemConnectorClass
     *
     * @return {String} CSS class values depending on whether document has attr dir="rtl"
     * @private
     */
    computeLocalizedItemConnector: function() {
      return document.documentElement.getAttribute("dir")==="rtl" ? "fa fa-chevron-left" : "fa fa-chevron-right";
    },

    /**
     * @param {Object} item
     * @return {String} Display label for given item
     */
    getItemLabel: function(item) {
      return item ? item[this.labelField] || '' : '';
    },

    /**
     * @param {Object} item
     * @return {String} Id for given item
     */
    getItemId: function(item) {
      return item ? item[this.idField] : null;
    },

    /**
     * @param {Object} item
     * @return {String} CSS class for item opener
     */
    getItemOpenerClass: function(item) {
      var base = "opener fa fa-share pull-right";
      return (this.handlers.isOpenable && this.handlers.isOpenable(item)) || item.openable
        ? base + " openable"
        : base + " unopenable";
    },

    /**
     * Observer on initial-contexts attribute / initialContexts property. Functions as the 'main' function of the component
     *
     * @private
     */
    initialContextsChanged: function(newValue, oldValue) {
      var initialContexts = this.initialContexts;
      if(typeof initialContexts==='string')
      {
        if(initialContexts.length>0 && initialContexts.indexOf("{{")=== -1)
        {
          initialContexts = JSON.parse(initialContexts);
        }
        else
        {
          initialContexts = null;
        }
      }
      var root = {hideBreadcrumb: true};
      this.parentNodes = [root];
      this.addChildren(root, initialContexts);
    },

    /**
     * Appends children to those already at a level and calls setDisplayNodes()
     *
     * @param {Object} item The parent
     * @param {Object} results Describes the children
     *  @config {Array} data List of children objects
     *  @config {Object} meta Keys describe the data.
     */
    appendChildren: function(item, results) {
      if(results===undefined || results===null)
      {
        return;
      }
      var children = results.data || [];

      // set up the parent pointers
      for(var i = 0; i<children.length; i++)
      {
        children[i].parent = item;
      }

      // adding all the new children onto the node's children
      Array.prototype.push.apply(item.children, children);

      // update the display
      this.setDisplayNodes();
    },

    /**
     * Add children to a level, overwriting any existing, and calls setDisplayNodes()
     *
     * @param {Object} parentNode The parent
     * @param {Object} results Describes the children
     *  @config {Array} data List of children objects
     *  @config {Object} meta Keys describe the data.
     */
    addChildren: function(parentNode, results) {

      if(results===undefined || results===null)
      {
        return;
      }
      var children = results.data || [];

      // set up the parent pointers
      for(var i = 0; i<children.length; i++)
      {
        children[i].parent = parentNode;
      }

      parentNode.children = children;
      parentNode.childrenCount = results.meta.total;

      // update the display
      this.setDisplayNodes();
    },

    /**
     * Drops all children of a given item and calls setDisplayNodes();
     *
     * @param {Object} item
     */
    dropCurrentChildren: function(item) {
      // drop the children from the master list of nodes (and update the level)
      for(var i = 0; i<this.parentNodes.length - 1; i++)
      {
        if(this.parentNodes[i]===item.parent)
        {
          this.parentNodes = this.parentNodes.slice(0, i + 1);
        }
      }

      // drop the children from the displayed nodes (so old nodes don't linger during next GET for children)
      for(var j = 0; j<this.displayNodes.length - 1; j++)
      {
        if(this.displayNodes[j]===item.parent)
        {
          this.displayNodes = this.displayNodes.slice(0, j + 1);
        }
      }
    },

    /**
     * Fetches all children of a given item
     *
     * @param {Object} item
     */
    getNewChildren: function(item) {
      if(this.handlers.getChildren)
      {
        // push the item to the parentNodes so breadcrumbs updated even if children not successfully returned
        this.parentNodes.push(item);
        var _this = this;
        this.handlers.getChildren(item[_this.idField]).then(
          function(children) {
            _this.addChildren(item, children);
          });
      }
      else
      {
        if(this.childKey)
        {
          this.addChildren(item, item[this.childKey]);
        }
        else if(item.subcontexts)
        {
          this.addChildren(item, item.subcontexts);
        }
        else
        {
          console.log('The next level of children could not be returned.');
          return; //do not put anything else in tree
        }
        this.parentNodes.push(item);
      }
    },

    /**
     * Marks an item as selected and fetches its children
     *
     * @param {Object} item
     * @param {Element} itemElement The element in the local DOM representing the given item. If not passed, will try to find it in the DOM based on item[this.idField]
     */
    selectItem: function(item, itemElement) {
      var columnEl, containerEl, _this = this, pDom = Polymer.dom;

      //execute callback
      if(this.handlers.itemClickHandler)
      {
        this.handlers.itemClickHandler(item);
      }

      //logically mark item as selected
      this.selectedItem = item;
      this.selectedItemId = item ? item[this.idField] : null;

      if(!itemElement && this.selectedItemId)
      {
        //if coming from breadcrumbs, we don't have an itemElement clicked...try to find it.
        pDom(this.root).querySelectorAll('section.columns li').every(
          function(el) {
            if(el.id===_this.selectedItemId)
            {
              itemElement = el;
              return false;
            }
            return true;
          });
      }

      //node finding...
      columnEl = itemElement ? pDom(itemElement).parentNode : pDom(this.root);

      //mark list item as selected in display and deselect others
      pDom(columnEl).querySelectorAll('li').forEach(
        function(el) {
          _this.toggleClass("selected", (el===itemElement), el);
        });

      //handle nesting of column els, such that they are not necessarily direct siblings
      containerEl = columnEl;
      while(containerEl && !containerEl.hasAttribute("data-column"))
      {
        containerEl = containerEl.parentNode;
      }

      //mark list/column as selected in display and deselect others
      pDom(containerEl.parentNode).querySelectorAll('ul').forEach(
        function(el) {
          _this.toggleClass("selected", (el===columnEl), el);
        });

      this.dropCurrentChildren(item);
      this.getNewChildren(item);
    },

    /**
     * Recalculates which items to display based on number of visible columns, and copies them into an Array used by the template.
     *
     * TBD if we need this if/when we move to more of a carousel approach, where we "render" all panels/columns but choose to show/hide/shift them based on number of visible columns
     * @private
     */
    setDisplayNodes: function() {
      var beginIndex = 0;
      if(this.treeDisplayLevels<this.parentNodes.length)
      {
        beginIndex = this.parentNodes.length - this.treeDisplayLevels;
      }
      var displayNodes = this.parentNodes.slice(beginIndex);
      while(displayNodes.length<this.treeDisplayLevels)
      {
        //pad to the end
        displayNodes.push({});
      }
      this.displayNodes = displayNodes;
    },

    /**
     * TBD whether we need this...only way to get 'handlers' correctly parsed in Polymer 0.5. May be able to dump now.  TBD.
     *
     * @private
     */
    ngScopeToken: "ngScope:",

    /**
     * TBD whether we need this...only way to get 'handlers' correctly parsed in Polymer 0.5. May be able to dump now.  TBD.
     *
     * @private
     */
    resolveNgScopeAttr: function(ngScope, attrName, attrValue) {
      var scopePath, scopeTokens, i, resolvedValue;
      if(attrValue.indexOf(this.ngScopeToken)===0)
      {
        scopePath = attrValue.substring(this.ngScopeToken.length);
        console.log("scopePath=" + scopePath);
        scopeTokens = scopePath.split('.');
        resolvedValue = ngScope;
        for(i = 0; i<scopeTokens.length; i++)
        {
          //iterate over the dots values in 'a.b.c' to find the final resolved value
          resolvedValue = resolvedValue[scopeTokens[i]];
        }
        this[attrName] = resolvedValue;
      }
    }

  });
</script>
