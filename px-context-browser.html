<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.sw.ge.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html"/>


<!--
3-column browser element

##### Usage

    <px-context-browser initial-contexts="{{ ... }}"
                        handlers="{{ ... }}"
                        label-field="{{ ... }}"
                        parent-id-field="{{ ... }}"
                        id-field="{{ ... }}"
                        headers="{{ ... }}"
                        child-key="{{ ... }}">
        <section class="context-info">optional, will appear below the breadcrumbs</section>
        <footer>optional, will appear in the footer</footer>
    </px-context-browser>

@element px-context-browser
@blurb 3-column browser element
@homepage index.html
-->
<dom-module id="px-context-browser">
  <link rel="import" type="css" href="css/px-context-browser.css" polyfill-next-selector/>
  <template>
    <div class="flex flex--column context-browser-container">
    <header class="p-- flex__item">
      <div hidden$="[[!showBreadcrumbs]]">
        <template is="x-repeat" id="breadcrumbs" items="{{parentNodes}}">
          <span hidden$="[[item.hideBreadcrumb]]">
            <span class="breadcrumb" on-click="handleBreadcrumbClick">[[item.name]]</span>
          </span>
          <span class="breadcrumbConnector" hidden$="[[item.hideBreadcrumb]]">[[parent.breadcrumbConnector]]</span>
        </template>
        &nbsp;
      </div>
      <div>
        <content select=".context-info"></content>
      </div>
    </header>
    <section class="flex columns flex__item">
      <template is="x-repeat" id="levels" items="{{displayNodes}}">
        <div class="flex__item p- column" data-column>
          <span>{{item.header}}</span>
          <ul class="list-bare level" on-scroll="scrollEndHandler">
            <!-- see https://groups.google.com/forum/#!topic/polymer-dev/CMQRzKPV5Ww for explanation of the '&& selectedItem' part below -->
            <template is="x-repeat" items="{{item.children}}" id="level">
              <li on-click="itemClickHandler" id$="[[parent.parent.getItemId(item)]]" class="selectable-item">
                <span>[[parent.parent.getItemLabel(item)]]</span>
                <span hidden$="[[!item.hasChildren]]" class="pull-right pl-">
                  <i class="fa fa-chevron-right"></i>
                </span>
                <i class$="[[parent.parent.getItemOpenerClass(item)]]" on-click="openClickHandler"></i>
              </li>
            </template>
            <li hidden$="[[!item.children || item.children.length === 0]]">This context has no children.</li> <!-- todo: i18n / messages. Runtime or build-time?? -->
          </ul>
        </div>
      </template>
    </section>
    <footer class="p-- clearfix flex__item" hidden$="[[!hasFooter]]">
      <content select="footer"></content>
      <content select=".footer"></content>
    </footer>
    </div>
  </template>
</dom-module>

<script>
Polymer({

  is: 'px-context-browser',
  properties: {
    parentIdField: {
      type: String
    },
    idField: {
      type: String
    },
    headers: {
    },
    treeDisplayLevels: {
      value : 1,
      type: Number
    },
    labelField: {
      type: String
    },
    selectedItemId: {
      value: null,
      type: String //need to reflect back properties to attributes per angular-bind-polymer
    },
    showBreadcrumbs: {
      value: true,
      type: Boolean
    },
    handlers:{
      type: Object,
      value:function(){ return {};}
    },
    initialContexts:{
      value: null,
      observer: 'initialContextsChanged'
    },
    parentNodes: {
      type: Array,
      value: []
    },
    breadcrumbConnector: {
      type: String,
      computed: 'computeLocalizedBreadcrumbConnector(selectedItemId)' //passing in selectedItemId as computed only fires when an arg passed to the fn changes
    }
  },

  ngScopeToken: "ngScope:",

  ready: function() {

    //hide the footer if empty (hidden$="..." doesn't help us here(?)
    var pDom = Polymer.dom(this.root);
    this.toggleClass('empty', (!pDom.querySelector('content .footer') && !pDom.querySelector('content footer')), pDom.querySelector('footer'));

    if (window['angular'] && this.hasAttributes()) {
      //if angular exists and was passed 'ngScope:a.b.c' for any attribute, fish object value from current angular scope.
      var ngScope = angular.element(this).scope();
      for (var i = 0; i < this.attributes.length; i++) {
        this.resolveNgScopeAttr(ngScope, this.attributes[i].name, this.attributes[i].value);
      }
    }
  },

  resolveNgScopeAttr: function(ngScope, attrName, attrValue) {
    var scopePath, scopeTokens, i, resolvedValue;
    if (attrValue.indexOf(this.ngScopeToken) === 0) {
      scopePath = attrValue.substring(this.ngScopeToken.length);
      console.log("scopePath=" + scopePath);
      scopeTokens = scopePath.split('.');
      resolvedValue = ngScope;
      for (i = 0; i < scopeTokens.length; i++) {
        //iterate over the dots values in 'a.b.c' to find the final resolved value
        resolvedValue = resolvedValue[scopeTokens[i]];
      }
      this[attrName] = resolvedValue;
    }
  },

  initialContextsChanged: function(newValue, oldValue) {
    var initialContexts = this.initialContexts;
    if (typeof initialContexts === 'string') {
      if (initialContexts.length > 0) {
        initialContexts = JSON.parse(initialContexts);
      }
      else {
        initialContexts = null;
      }
    }
    var root = {hideBreadcrumb: true};
    this.parentNodes = [root];
    this.addChildren(root, initialContexts);
  },

  displayNodes: null,

  appendChildren: function (item, results) {
    if (results === undefined || results === null) {
      return;
    }
    var children = results.data || [];

    // set up the parent pointers
    for (var i = 0; i < children.length; i++) {
      children[i].parent = item;
    }

    // adding all the new children onto the node's children
    Array.prototype.push.apply(item.children, children);

    // update the display
    this.setDisplayNodes();
  },

  addChildren: function(parentNode, results) {

    if (results === undefined || results === null) {
      return;
    }
    var children = results.data || [];

    // set up the parent pointers
    for (var i = 0; i < children.length; i++) {
      children[i].parent = parentNode;
    }

    parentNode.children = children;
    parentNode.childrenCount = results.meta.total;

    // update the display
    this.setDisplayNodes();
  },

  handleBreadcrumbClick: function(evt) {
    var level = this.$.breadcrumbs.indexForElement(evt.target); //"$.breadcrumbs" is id of the template element with x-repeat
    this.selectItem(this.parentNodes[level]);
  },

  computeLocalizedBreadcrumbConnector: function() {
    return document.documentElement.getAttribute("dir") === "rtl" ? "<" : ">";
  },

  isShowChildren: function(item) {
    return item.children.length > 0 && this.selectedItem;
  },

  isShowEmptyMsg: function(item) {
    return !item.children || item.children.length === 0;
  },

  getItemLabel: function(item) {
    return item[this.labelField];
  },

  getItemBreadcrumb: function(item) {
    return item ? item[this.labelField] || '' : '';
  },

  getItemId: function(item) {
    return item ? item[this.idField] : null;
  },

  getItemOpenerClass: function(item) {
    var base = "opener fa fa-share pull-right";
    return (this.handlers.isOpenable && this.handlers.isOpenable(item)) || item.openable ? base +" openable" : base + " unopenable";
  },

  dropCurrentChildren: function(item) {
    // drop the children from the master list of nodes (and update the level)
    for (var i = 0; i < this.parentNodes.length - 1; i++) {
      if (this.parentNodes[i] === item.parent) {
        this.parentNodes = this.parentNodes.slice(0, i + 1);
      }
    }

    // drop the children from the displayed nodes (so old nodes don't linger during next GET for children)
    for (var j = 0; j < this.displayNodes.length - 1; j++) {
      if (this.displayNodes[j] === item.parent) {
        this.displayNodes = this.displayNodes.slice(0, j + 1);
      }
    }
  },

  getNewChildren: function(item) {
    if (this.handlers.getChildren) {
      // push the item to the parentNodes so breadcrumbs updated even if children not successfully returned
      this.parentNodes.push(item);
      var _this = this;
      this.handlers.getChildren(item[_this.idField]).then(function (children) {
        _this.addChildren(item, children);
      });
    }
    else {
      if (this.childKey) {
        this.addChildren(item, item[this.childKey]);
      }
      else if (item.subcontexts) {
        this.addChildren(item, item.subcontexts);
      }
      else {
        console.log('The next level of children could not be returned.');
        return; //do not put anything else in tree
      }
      this.parentNodes.push(item);
    }
  },

  itemClickHandler: function(evt) {
    var levelTemplateRepeat = Polymer.dom(this.root).querySelector('template#level');//can't use this.$.id to find this template as it is within an x-repeat
    var item = levelTemplateRepeat.itemForElement(evt.target);
    this.selectItem(item, evt.currentTarget);
  },

  selectItem: function(item, itemElement) {
    var columnEl, containerEl, _this = this, pDom = Polymer.dom;

    //execute callback
    if (this.handlers.itemClickHandler) {
      this.handlers.itemClickHandler(item);
    }

    //logically mark item as selected
    this.selectedItem = item;
    this.selectedItemId = item ? item[this.idField] : null;

    if (!itemElement && this.selectedItemId) {
      //if coming from breadcrumbs, we don't have an itemElement clicked...try to find it.
      pDom(this.root).querySelectorAll('section.columns li').every(function(el) {
        if (el.id === _this.selectedItemId) {
          itemElement = el;
          return false;
        }
        return true;
      });
    }

    //node finding...
    columnEl = itemElement ? pDom(itemElement).parentNode: pDom(this.root);

    //mark list item as selected in display and deselect others
    pDom(columnEl).querySelectorAll('li').forEach(function(el) {
      _this.toggleClass("selected", (el === itemElement), el);
    });

    //handle nesting of column els, such that they are not necessarily direct siblings
    containerEl = columnEl;
    while (containerEl && !containerEl.hasAttribute("data-column")) {
      containerEl = containerEl.parentNode;
    }

    //mark list/column as selected in display and deselect others
    pDom(containerEl.parentNode).querySelectorAll('ul').forEach(function(el) {
      _this.toggleClass("selected", (el === columnEl), el);
    });

    this.dropCurrentChildren(item);
    this.getNewChildren(item);
  },

  scrollEndHandler: function (evt, detail, sender) {
    // executes when it hasn't been called for 500ms
    var _this = this;
    var levelIdx = this.$.levels.indexForElement(evt.target);
    this.debounce('scroll-panel', function() {
      if (this.handlers.getChildren) {
        var item = this.parentNodes[levelIdx];
        if (!item || !item.childrenCount || (item.childrenCount !== undefined && item.children.length >= item.childrenCount)) {
          return;
        }
        this.handlers.getChildren(item[_this.idField], item.children.length).then(function (children) {
          _this.appendChildren(item, children);
        });
      }
    }, 500);
  },

  openClickHandler: function(evt) {
    evt.stopPropagation();
    if (this.selectedItem && this.handlers.itemOpenHandler) {
      var breadcrumbs = [];
      for (var index in this.parentNodes) {
        if (index < this.parentNodes.length - 1) {
          breadcrumbs.push(this.getItemBreadcrumb(this.parentNodes[index], index));
        }
      }
      this.handlers.itemOpenHandler(this.selectedItem, breadcrumbs);
    }
  },

  setDisplayNodes: function() {
    var beginIndex = 0;
    if (this.treeDisplayLevels < this.parentNodes.length) {
      beginIndex = this.parentNodes.length - this.treeDisplayLevels;
    }
    var displayNodes = this.parentNodes.slice(beginIndex);
    while (displayNodes.length < this.treeDisplayLevels) {
      //pad to the end
      displayNodes.push({});
    }
    this.displayNodes = displayNodes;
  }

});
</script>
