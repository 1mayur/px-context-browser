<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.sw.ge.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<!--suppress HtmlUnknownTarget -->
<link rel="import" href="../polymer/polymer.html"/>

<style>
  [dir=rtl] .fa.px-context-browser {
    -webkit-transform: scale(-1, 1);
    transform: scale(-1, 1);
  }

  [dir=rtl] .fa.px-context-browser {
    -webkit-transform: scale(-1, 1);
    transform: scale(-1, 1);
  }
</style>

<!--
Context browser element.  See the demo page (demo.html) for a working example.

#### Initial Context Simple Usage

    <px-context-browser></px-context-browser>

```js
// The following object used to be initialContexts, which is now deprecated,
// and is discouraged.
  var context = {
    data: [{
      "name": "Turbine 74",
      "id": "001-1",
      "isOpenable": true
    }, {
      "name": "Turbine 57",
      "id": "001-2",
      "isOpenable": false
    }],
    meta: {
      parentId: null
    }
  };

  window.addEventListener('WebComponentsReady', function() {
    var colBrowser = document.querySelector('px-context-browser');
    colBrowser.handlers = {
      getChildren: function(parent, newIndex) {
        return demoGetChildren(parent, newIndex);
      },
      itemOpenHandler: function(context) {
        console.log('Opened: ', context);
      }
    };
    if (typeof initialContexts !== "undefined" ) {
      colBrowser.initialContexts = initialContexts;
    } else {
      if (context.contextType === "directContext") {
        colBrowser.directContext = context;
      } else if (context.contextType === "initialContext") {
        colBrowser.initialContexts = initialContexts;
      }
    }
  });
```


#### Initial Context Custom Data Format Support

    <px-context-browser label-field="description"
                        parent-id-field="parent"
                        id-field="identifier">
    </px-context-browser>

```js

// The following object used to be initialContexts, which is now deprecated,
// and is discouraged.
  var context = {
    data: [{
      "description": "Turbine 1",
      "identifier": "001-1",
      "parent": "top",
      "hasChildren": true
    }, {
      "description": "Turbine 2",
      "identifier": "001-2",
      "parent": "top",
      "hasChildren": true
    }],
    meta: {
      parentId: null
    }
  };
```

### Direct Context use

    <px-context-browser></px-context-browser>

```
var context ={
  "data": [
      {
          "identifier": "001-1",
          "name": "Lots of Children",
          "isOpenable" : true
      },
      {
        "identifier": "001-2",
        "name": "Deep nested",
        "isOpenable" : true,
        "children": [
              {
                  "identifier": "001-2a",
                  "name": "Nested Child 1",
                  "isOpenable" : true,
                  "children": [
                    {
                      "identifier": "001-2aa",
                      "name": "Nested Grandchild 1",
                      "isOpenable" : true,
                      "children" : [{
                        "identifier": "001-2aba",
                        "name": "Nested Great Grandchild 1",
                        "isOpenable" : true
                      },
                      {
                        "identifier": "001-2abb",
                        "name": "Nested Great Grandchild 2",
                        "isOpenable" : true
                      },
                      {
                        "identifier": "001-2abc",
                        "name": "Nested Great Grandchild 3",
                        "isOpenable" : true,
                        "selectedAsset": true
                      }],
                      "meta": { "parentId": "001-2ab" }
                    },
                    {
                      "identifier": "001-2ab",
                      "name": "Nested Grandchild 2",
                      "isOpenable" : true,
                    },
                    {
                      "identifier": "001-2ac",
                      "name": "Nested Grandchild 3",
                      "isOpenable" : true
                    }
                  ],
                  "meta": { "parentId": "001-2a" }
              },
              {
                "identifier": "001-2b",
                "name": "Nested Child 2",
                "isOpenable" : true
              },
              {
                "identifier": "001-2c",
                "name": "Nested Child 3",
                "isOpenable" : true
              }
          ],
          "meta": { "parentId": "001-2" }
      },
      {
      "identifier": "001-3",
      "name": "Nothing Below Me",
      "isOpenable" : true
      },
      {
      "identifier": "001-4",
      "name": "Nothing Below, Not openable"
     }
  ],
  "meta": { "parentId": null }
};
```

@element px-context-browser
@blurb Context browser element
@homepage index.html
@demo demo.html

-->
<dom-module id="px-context-browser">
  <link rel="import" type="css" href="css/px-context-browser.css" polyfill-next-selector/>
  <template>
    <div id="modal" on-click="toggleColumnBrowser" hidden$="{{!showColumnBrowser}}"></div>
    <div id="back">
      <div class="column-browser-container flex flex--col">
        <header class="flex u-pl" id="selectContext">
          <div class="content-wrapper">
            <content></content>
          </div>
          <div class="flex__item--middle">
            <h1 class="epsilon caps weight--normal u-m0" on-click="toggleColumnBrowser">
              <span>{{openedItemName}}</span>
              <i class="fa fa-caret-down"></i>
            </h1>
            <ul class="list-inline list-inline--delimited">
              <template is="dom-repeat" items="{{openedBreadcrumbs}}">
                <li>[[item]]</li>
              </template>
            </ul>
          </div>
        </header>
        <div id="ruler" hidden$="{{!showColumnBrowser}}" class="flex flex--col">
            <div hidden$="{{!showColumnBrowser}}" class="flex flex--col">
              <ul class="breadcrumbs list-inline list-inline--delimited">
                <template is="dom-repeat" id="breadcrumbs" items="{{parentNodes}}">
                  <li hidden$="[[item.hideBreadcrumb]]">
                    <span class="breadcrumb" on-click="handleBreadcrumbClick">{{item.name}}</span>
                  </li>
                </template>
              </ul>
              <div class="flex flex--col column-browser" id="columnBrowser">
                <div class="flex">
                  <template is="dom-repeat" id="levels" items="{{parentNodes}}">
                    <div class="flex flex--col column push" data-column>
                      <div class="head">{{ item.header || '' }}</div>
                      <div class="flex__item scroll-y" on-scroll="scrollEndHandler">
                        <ul class$="{{directContextUlSelected(item, selectedItem)}}">
                          <template is="dom-repeat" id="level" items="{{item.children}}">
                            <li on-click="itemClickHandler" id$="[[getItemId(item)]]"
                                class$="{{isItemSelected(item, selectedItem)}}"  >
                              <span class="flex__item">{{getItemLabel(item)}}</span>
                              <button class$="[[getItemOpenerClass(item)]]" on-click="openClickHandler"
                                   key$="[[getItemId(item)]]">Open
                              </button>
                              <span hidden$="[[!item.hasChildren]]"><i class="fa fa-angle-right"></i></span>
                            </li>
                          </template>
                          <li hidden$="[[!item.children || item.children.length === 0]]">This context has no children.</li>
                          <!-- todo: i18n / messages. Runtime or build-time?? -->
                        </ul>
                      </div>
                    </div>
                  </template>
                </div>
                <!-- Avoid ruler being part of the structure but being within a container that can enforce its relative size -->
                <div class="ruler">
                  <!-- Use this as a ruler/measuring-stick to measure the true minimum width. -->
                </div>
              </div>
            </div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer(
    {
      is: 'px-context-browser',
      properties: {

        /**
         * Mapping for the field name in the context data that represents the display label for an item. This property allows data of any form/keys to be used as
         * long as it has the notion of a 'display label' in it.
         *
         * @type {String}
         * @default "name"
         */
        labelField: {
          type: String,
          value: "name"
        },
        /**
         * contains the selected item data
         *
         * @type {Object}
         * @default null
         */
        selectItem: {
          type: Object,
          value: null
        },
        /**
         * Mapping for the field name in the context data that represents a unique id for an item. This property allows data of any form/keys to be used as
         * long as it has the notion of a 'unique id' in it.
         * @type {String}
         * @default "id"
         */
        idField: {
          type: String,
          value: "id"
        },
        // /**
        //  * Starting level of context. Contains an Array of items that include keys that match the "idField"
        //  *  and "labelField" properties on this component.
        //  * Optional. Setting this property is essentially to this component's initialContexts function.
        //  * @type {Object}
        //  * @Optional
        //  */
        // initialContexts: {
        //   value: null,
        //   observer: 'initialContextsChanged'
        // },
        // /**
        //  * Full tree of  directly selected item, drilling all the way down to the selected item.
        //  * (for example, through ng-bind-polymer - https://github.com/PredixDev/ng-bind-polymer)
        //  * Optional.
        //  * @type {object}
        //  * @Optional
        //  */
        // directContext : {
        //   value: null,
        //   observer: 'directContextChanged'
        // },
        // /**
        //  * Id of item currently selected, reflected back as an attribute so application can detect which item is selected
        //  * (e.g. via ng-bind-polymer - https://github.com/PredixDev/ng-bind-polymer)
        //  *
        //  * @type {String}
        //  */
        browserContext : {
            value: null,
            type: function() {return {};},
            observer: 'contextChanged'
        },
        selectedItemId: {
          type: String,
          value: null,
          reflectToAttribute: true
        },
        /**
         * Object defining some or all of the following functions as members:
         *
         * ```js
         * itemOpenHandler: function(item) {}
         *  // returns special callback behavior when
         *  // a given context item is opened
         * itemClickHandler: function(item) {}
         *   // returns special callback behavior when
         *   // a given context is selected
         * getChildren: function (parent, startIdx) {}
         *   // returns a JavaScript promise that will
         *   // resolve to children of the item and
         *   // starting with the given index (to support lazy loading)
         *```
         *
         * @type {Object}
         */
        handlers: {
          type: Object
        },
        /**
         * Hierarchy of items down to currently selected item. Set here as a property to expose it to the template, but managed internally. Do not set this.
         *
         * @type {Array}
         * @default []
         * @private
         */
        parentNodes: {
          type: Array,
          value: function() {return [];} //this is Polmer's way of defining an empty array in properties
        },
        /**
         * Initial context name to be shown on page
         *
         * @type {String}
         * @default 'Selected Context'
         */
        openedItemName: {
          type: String,
          value: 'Select Context'
        },
        /**
         * flag to show column browser
         * @type {Boolean}
         * @default false
         */
        showColumnBrowser: {
          type: Boolean,
          value: false
        },
        /**
         * opened item breadcrumb
         * @type {Array}
         * @default []
         * @private
         */
        openedBreadcrumbs: {
          type: Array,
          value: function() {return [];}
        }
      },
      ready: function() {
        var _this = this;

        //use setTimeout to yield for angular databind to populate the handlers
        setTimeout(function() {
          //TBD whether we need _this.
          if (window['angular'] && _this.hasAttributes()) {
            //if angular exists and was passed 'ngScope:a.b.c' for any attribute, fish object value from current angular scope.
            var ngScope = angular.element(_this.root).scope();
            for (var i = 0; i < _this.attributes.length; i++) {
              _this.resolveNgScopeAttr(ngScope, _this.attributes[i].name, _this.attributes[i].value);
            }
          }
        }, 0);

        // Need to watch the width of the column-browser.
        var columnBrowser = this.$.columnBrowser,
            columnBrowserColumnRuler = Polymer.dom(columnBrowser).querySelector('.ruler'),
            columnBrowserColumns = Polymer.dom(columnBrowser).querySelector('div:first-child'),
            columnBrowserColumnsBaseCss = columnBrowserColumns.className, // Polymer does weird stuff.
            $columnBrowserColumns = Polymer.dom(columnBrowserColumns),
            contextBrowserWidth, contextBrowserChildrenCount;

             // Watch the container size change.
        var getColumns = function() {
          return $columnBrowserColumns.childNodes.filter(
            function(n) {
              return n.tagName === 'DIV';
            });
        };

        setInterval(
          function() {
            var width = columnBrowser.offsetWidth,
                removedCount = $columnBrowserColumns.querySelectorAll('.removed').length,
                cCount = columnBrowserColumns.childNodes.length - removedCount;

            if (width !== contextBrowserWidth || cCount !== contextBrowserChildrenCount) {
              contextBrowserWidth = width;
              contextBrowserChildrenCount = cCount;
              var count = getColumns().length - removedCount,
                  columns = Math.floor(width / columnBrowserColumnRuler.offsetWidth),
                  desiredClass = columnBrowserColumnsBaseCss + ' columns-' + columns;

              if (count > columns) {
                desiredClass += " column-index-" + (count - columns);
              }

              if (columnBrowserColumns.className !== desiredClass) {
                columnBrowserColumns.className = desiredClass;
              }
            }
          }, 1000 / 20); // ms/fps

        /*
         Dilemma:
         How to synchronize with databinding.
         Steps that have to happen:
         1) Item gets added to dom.
         2) A frame passes to allow for rendering.
         3) Then remove 'new' class.
         */
        var removeNewTagInternal = function() {
          var found = false;
          getColumns().forEach(
            function(c) {
              // 1) We detect the 'new' item in the actual dom.
              if (c.classList.contains('new')) {
                // 2) delay one frame to remove it.
                requestAnimationFrame(
                  function() {
                    // 3) Remove
                    c.classList.remove('new');
                  });
                found = true;
              }
            });
          return found;
        };

        var removeNewTag = function() {
          var wait = function() {
            // A new item is expected, so wait till it arrives.
            if (!removeNewTagInternal()) {// Not found?  Wait for next frame.
              requestAnimationFrame(wait);
            }
          };
          requestAnimationFrame(wait);
        };

        this.removeNewTag = removeNewTag;
        removeNewTag();
      },
      /**
       * Removes 'new' tag from class name to allow for css animation.
       *
       * @private
       */
      removeNewTag: function() {
      },

      /**
       * Event listener on breadcrumb clicks, listener is registered from the template
       *
       * @param {Event} evt
       * @private
       */
      handleBreadcrumbClick: function(evt) {
        var level = this.$.breadcrumbs.indexForElement(evt.target); //"$.breadcrumbs" is id of the template element with a dom-repeat
        this.selectItem(this.parentNodes[level]);
      },

      /**
       * Event listener on item clicks, listener is registered from the template
       *
       * @param {Event} evt
       * @private
       */
      itemClickHandler: function(evt) {
        this.debounce('itemClick', function() {
          this.selectItem(evt.model.item, evt.currentTarget);
        }, 1);
      },

      /**
       * Event listener on scroll of item panels/columns, listener is registered from the template
       *
       * @param {Event} evt
       * @private
       */
      scrollEndHandler: function(evt) {
        this.debounce(
          'scroll-panel', function() {
            // executes when it hasn't been called for 500ms
            var _this = this,
                levelIdx = this.$.levels.indexForElement(evt.target),
                scrollableHeight = evt.target.scrollHeight,
                visibleHeight = evt.target.offsetHeight,
                threshold = 10,
                hiddenContentHeight = scrollableHeight - visibleHeight;
            if (hiddenContentHeight - evt.target.scrollTop <= threshold) {
              if (this.handlers.getChildren) {
                var item = this.parentNodes[levelIdx],
                    options = {};
                if (item && item.meta) {
                  if (item.meta.total) {
                    if (item.children.length >= item.meta.total) {
                      return;
                    }
                    else {
                      options.rangeStart = item.children.length;
                    }
                  }
                  else {
                    options = item.meta;
                  }

                  this.handlers.getChildren(item, options).then(
                    function(children) {
                      _this.appendChildren(item, children);
                    });
                }
              }
            }
          }, 200);
      },
      /**
       * Event listener on 'open' button of open-able items, listener is registered from the template
       *
       * @param {Event} evt
       * @private
       */
      openClickHandler: function(evt) {
        evt.stopPropagation();
        if (this.selectedItem && this.handlers.itemOpenHandler) {
          this.configureBreadcrumbs(evt);
          this.openedItemName = this.selectedItem.name;
          this.toggleColumnBrowser();
          this.handlers.itemOpenHandler(this.selectedItem, this.openedBreadcrumbs);
        }
      },
      /**
       * Configure the breadcrumb trail from both the parentNode and/or the selected name.
       *
       * @param {Event} evt
       * @private
       */
      configureBreadcrumbs: function(evt) {
        this.splice('openedBreadcrumbs', 0, this.openedBreadcrumbs.length);
        for (var index in this.parentNodes) {
          if (index < this.parentNodes.length) {
            if (this.getItemLabel(this.parentNodes[index]) !== '') {
              this.push('openedBreadcrumbs', this.getItemLabel(this.parentNodes[index]));
            }
          }
        }
      },
      /**
       * @param {Object} item
       * @return {String} Display label for given item
       * @private
       */
      getItemLabel: function(item) {
        return item ? item[this.labelField] || '' : '';
      },
      /**
       * @param {Object} item
       * @return {String} Id for given item
       * @private
       */
      getItemId: function(item) {
        return item ? item[this.idField] : null;
      },
      /**
       * @param {Object} item
       * @return {String} CSS class for item opener
       * @private
       */
      getItemOpenerClass: function(item) {
        var base = "opener btn btn--small btn--tertiary ";
        return base = (item.isOpenable) ? base + "openable" : base + "unopenable";
      },
      /**
       * @param {String} base
       * @return {String} CSS class for item
       * @private
       */
      isItemSelected: function(item, selectedItem) {
        var base = "flex flex--middle selectable-item";
        return base = (item.inSelectedPath) ? base += " selected" : base;
      },
      /**
       * Observer on directContext attribute. Functions as the 'main' function of the component if initialContexts is not set
       *
       * @private
       */
      contextChanged: function() {
        var _this= this,
            context = this.browserContext,
            root;
        console.log(context);
        //make sure it's a json object, and if it is, parse it.
        if (typeof context === 'object' && context !== null) {
          //if (context.length > 0 && context.indexOf("{{") === -1) {
            //context = JSON.parse(context);
          // }
          // else {
          //   context = null;
          // }
        }
        root = {hideBreadcrumb: true};
        this.parentNodes = [];
        this.openedBreadcrumbs = [];

        this.push('parentNodes', root);
        //this.addChildren(root, context);

        //dig into the tree, and keep going while we have children
        //function recursiveAddChildren(currentRoot) {
          var current_elem;
          // for (var i in currentRoot) {
          //   current_elem = currentRoot[i];
          //   if(Object.keys(current_elem).indexOf('children') > -1) {
          //       current_elem.inSelectedPath = true;
          //     //only direct lineage of the selected child have children..
          //     _this.push('parentNodes',current_elem);
          //     var obj = {"data" : current_elem.children};
          //     _this.addChildren(current_elem, obj);
          //     recursiveAddChildren(current_elem.children);
          //   } else if (current_elem.selectedAsset) {
          //       current_elem.inSelectedPath = true;
          //       _this.set('selectedItem',current_elem);
          //     //we're pushing this item into parentNode to ensure the breadcrumbs work correctly.
          //     _this.push('parentNodes',current_elem);
          //   }
          // }
        if (context !== null) {
            Object.keys(context.data).forEach(function(i) {
              console.log(context.data[i]);
          do {
            if (context.data[i].children) {
              current_elem = context.data[i].children;
            } else {
              current_elem = context.data[i];
            }


            if (Object.keys(current_elem).indexOf('children') > -1 || current_elem.selectedAsset) {
              current_elem.inSelectedPath = true;
            }

            if (current_elem.selectedAsset) {
              _this.set('selectedItem',current_elem);
            }
            _this.push('parentNodes',current_elem);

            if (current_elem.children) {
              var obj = {"data" : current_elem.children};
              _this.addChildren(current_elem, obj);
              //current_elem
            }
          } while (Object.keys(current_elem).indexOf('children') > -1);
        });
      }

      //  }
      //  recursiveAddChildren(root.children);
        this.removeNewTag();
      },
      /**
       * Observer on initial-contexts attribute / initialContexts property. Functions as the 'main' function of the component
       *
       * @private
       */
      initialContextsChanged: function(newValue, oldValue) {
        var initialContexts = this.initialContexts,
            root;
        if (typeof initialContexts === 'string') {
          if (initialContexts.length > 0 && initialContexts.indexOf("{{") === -1) {
            initialContexts = JSON.parse(initialContexts);
          }
          else {
            initialContexts = null;
          }
        }
        root = {hideBreadcrumb: true};
        this.parentNodes = [];
        this.openedBreadcrumbs = [];
        this.push('parentNodes', root);
        this.addChildren(root, initialContexts);
        this.removeNewTag();
        //we have to put out a notifyPath to ensure the correct classes are passes into the lIs and ULs on initialContexts load
        this.notifyPath('selectedItem', '');
      },
      /**
       * Appends children to those already at a level.
       *
       * @param {Object} item The parent
       * @param {Object} results Describes the children
       *  @config {Array} data List of children objects
       *  @config {Object} meta Keys describe the data.
       *  @private
       */
      appendChildren: function(item, results) {
        if (results === undefined || results === null) {
          return;
        }
        var children = results.data || [];

        // set up the parent pointers
        for (var i = 0; i < children.length; i++) {
          children[i].parent = item;
        }
        item.meta = results.meta;
        // adding all the new children onto the node's children
        Array.prototype.push.apply(item.children, children);
      },
      /**
       * Add children to a level, overwriting any existing.
       *
       * @param {Object} parentNode The parent
       * @param {Object} results Describes the children
       *  @config {Array} data List of children objects
       *  @config {Object} meta Keys describe the data.
       *  @private
       */
      addChildren: function(parentNode, results) {
        if (results === undefined || results === null) {
          return;
        }
        var children = results.data || [];
        // set up the parent pointers
        for (var i = 0; i < children.length; i++) {
          children[i].parent = parentNode;
        }

        parentNode.children = children;
        parentNode.meta = results.meta;
      },
      /**
       * Drops all children of a given item;
       *
       * @param {Object} item
       * @private
       */
      dropCurrentChildren: function(item) {
        // drop the children from the master list of nodes (and update the level)
        for (var i = 0; i < this.parentNodes.length - 1; i++) {
          if (this.parentNodes[i] === item.parent) {
            this.parentNodes = this.parentNodes.slice(0, i + 1);
          }
        }
      },

      /**
       * @private
       */
      addToParentNodes: function(item) {
        var found = false,
            i = 0;

        while (i < this.parentNodes.length && !found) {
          if (this.parentNodes[i][this.idField] && this.parentNodes[i][this.idField] === item[this.idField]) {
            // if it is already in the parent nodes, then don't add it
            return;
          }
          i++;
        }
        this.push('parentNodes', item);
      },

      /**
       * Fetches all children of a given item
       *
       * @param {Object} item
       * @private
       */
      getNewChildren: function(item) {
        if (this.handlers.getChildren) {
          var _this = this;
          this.handlers.getChildren(item).then(
            function(data) {
              var children = data.data,
                  parentId = data.meta.parentId,
                  selectedNode = _this.selectedItem;

              if (parentId === undefined || parentId === null) {
                console.warn('Context tree getChildren response must have meta.parentId defined.');
              }
              //check response is for the current selected node
              else if (parentId === selectedNode[_this.idField]) {
                _this.addChildren(item, data);

                if (children.length > 0) {
                  _this.removeNewTag();
                }

                _this.addToParentNodes(item);
              } else {
                // disregard response, it's from an old getChildren call
              }
          });
        }
      },

      /**
       * Marks an item as selected and fetches its children
       *
       * @param {Object} item
       * @param {Element} itemElement The element in the local DOM representing the given item. If not passed, will try to find it in the DOM based on item[this.idField]
       * @private
       */
      selectItem: function(item, itemElement) {
        var _this = this;

        // Defer this execution since event handlers may be listening to dom targets that will end up getting removed and can cause unexpected problems.
        // By doing so, we allow an event to complete before changing the DOM.
        setTimeout(function() {
          //execute callback
          if (_this.handlers.itemClickHandler) {
            _this.handlers.itemClickHandler(item);
          }

          _this.changeSelected(item);
          _this.dropCurrentChildren(item);
          _this.getNewChildren(item);
        }, 0);
      },
      /**
       * Finds out if the passed UL has a child that's selected, and if so, add selected to the return path
       *
       * @param {Object} item
       * @param {selectedItem} the selected item.
       * @private
       */
      directContextUlSelected: function(item, selectedItem) {
        var base = "list-bare level",
            itemId = selectedItem.identifier;
        if (item.children) {
          item.children.forEach(function(child) {
            if (child.identifier === itemId) {
              base += " selected";
            }
          });
        }
        return base;
      },
      /**
       * resets all the selected siblings items, and sets the selected item.
       *
       * @param {Object} item
       * @private
       */
      changeSelected: function(item) {
        //make sure none of the siblings are marked as selected, and only the selected item IS.
        item.parent.children.forEach(function(sib) {
          //if you're a sibling, turn off all selectedPath/selectedAsset flags
          if (sib.identifier !== item.identifier) {
            if (sib.inSelectedPath || sib.selectedAsset) {
              sib.inSelectedPath = false;
              sib.selectedAsset = false;
            }
          // only turn those on if you're the selected Item.
          } else {
            sib.inSelectedPath = true;
            sib.selectedAsset = true;
          }
        });
        item.parent.selectedColumn = true;
        //change the itemId, and notify polymer to re-run the templates
        this.set('selectedItem', item);
      },
      /**
       * TBD whether we need this...only way to get 'handlers' correctly parsed in Polymer 0.5. May be able to dump now.  TBD.
       *
       * @private
       */
      ngScopeToken: "ngScope:",

      /**
       * TBD whether we need this...only way to get 'handlers' correctly parsed in Polymer 0.5. May be able to dump now.  TBD.
       *
       * @private
       */
      resolveNgScopeAttr: function(ngScope, attrName, attrValue) {
        var scopePath, scopeTokens, i, resolvedValue;
        if (attrValue.indexOf(this.ngScopeToken) === 0) {
          scopePath = attrValue.substring(this.ngScopeToken.length);

          scopeTokens = scopePath.split('.');
          resolvedValue = ngScope;
          for (i = 0; i < scopeTokens.length; i++) {
            //iterate over the dots values in 'a.b.c' to find the final resolved value
            resolvedValue = resolvedValue[scopeTokens[i]];
          }
          this[attrName] = resolvedValue;
        }
      },
      /**
       * toggle visbility of the column browser
       */
      toggleColumnBrowser: function() {
        this.showColumnBrowser = !this.showColumnBrowser;
      }
    });
</script>
